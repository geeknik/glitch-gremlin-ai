import * as tf from '@tensorflow/tfjs-node';
import { MLModel } from './ml-model';

export enum VulnerabilityType {
    BUFFER_OVERFLOW = 'BUFFER_OVERFLOW',
    INTEGER_OVERFLOW = 'INTEGER_OVERFLOW',
    REENTRANCY = 'REENTRANCY',
    ACCESS_CONTROL = 'ACCESS_CONTROL',
    ARITHMETIC_OVERFLOW = 'ARITHMETIC_OVERFLOW',
    NONE = 'NONE'
}

export interface VulnerabilityPrediction {
    type: VulnerabilityType;
    confidence: number;
    details: string[];
}

export interface TrainingDataPoint {
    features: number[];
    vulnerabilityType: VulnerabilityType;
}

export class VulnerabilityDetectionModel extends MLModel {
    constructor() {
        super();
    }

    async trainWithData(data: TrainingDataPoint[]): Promise<void> {
        if (!data || data.length === 0) {
            throw new Error('Training data cannot be empty');
        }

        const features = data.map(d => d.features);
        const labels = data.map(d => this.vulnerabilityTypeToLabel(d.vulnerabilityType));

        await this.train(features, labels);
    }

    async predictVulnerability(features: number[]): Promise<VulnerabilityPrediction> {
        const result = await this.predict(features);
        const vulnerabilityType = this.labelToVulnerabilityType(result.confidence);

        return {
            type: vulnerabilityType,
            confidence: result.confidence,
            details: this.generateDetails(vulnerabilityType, result.confidence)
        };
    }

    private vulnerabilityTypeToLabel(type: VulnerabilityType): number {
        switch (type) {
            case VulnerabilityType.BUFFER_OVERFLOW:
                return 1;
            case VulnerabilityType.INTEGER_OVERFLOW:
                return 0.8;
            case VulnerabilityType.REENTRANCY:
                return 0.6;
            case VulnerabilityType.ACCESS_CONTROL:
                return 0.4;
            case VulnerabilityType.ARITHMETIC_OVERFLOW:
                return 0.2;
            case VulnerabilityType.NONE:
                return 0;
            default:
                return 0;
        }
    }

    private labelToVulnerabilityType(confidence: number): VulnerabilityType {
        if (confidence > 0.9) return VulnerabilityType.BUFFER_OVERFLOW;
        if (confidence > 0.7) return VulnerabilityType.INTEGER_OVERFLOW;
        if (confidence > 0.5) return VulnerabilityType.REENTRANCY;
        if (confidence > 0.3) return VulnerabilityType.ACCESS_CONTROL;
        if (confidence > 0.1) return VulnerabilityType.ARITHMETIC_OVERFLOW;
        return VulnerabilityType.NONE;
    }

    private generateDetails(type: VulnerabilityType, confidence: number): string[] {
        const details = [`Detected vulnerability type: ${type}`];
        details.push(`Confidence score: ${(confidence * 100).toFixed(2)}%`);

        details.push('Recommendations:');
        switch (type) {
            case VulnerabilityType.BUFFER_OVERFLOW:
                details.push('- Implement proper bounds checking');
                details.push('- Use safe buffer manipulation functions');
                break;
            case VulnerabilityType.INTEGER_OVERFLOW:
                details.push('- Use SafeMath operations');
                details.push('- Implement range validation');
                break;
            case VulnerabilityType.REENTRANCY:
                details.push('- Implement checks-effects-interactions pattern');
                details.push('- Use reentrancy guards');
                break;
            case VulnerabilityType.ACCESS_CONTROL:
                details.push('- Implement proper authorization checks');
                details.push('- Use role-based access control');
                break;
            case VulnerabilityType.ARITHMETIC_OVERFLOW:
                details.push('- Use checked math operations');
                details.push('- Implement value range validation');
                break;
        }

        return details;
    }
}

export function generateTrainingData(count: number): TrainingDataPoint[] {
    const data: TrainingDataPoint[] = [];
    const vulnerabilityTypes = Object.values(VulnerabilityType);

    for (let i = 0; i < count; i++) {
        const features = new Array(20).fill(0).map(() => Math.random());
        const vulnerabilityType = vulnerabilityTypes[Math.floor(Math.random() * vulnerabilityTypes.length)];

        data.push({
            features,
            vulnerabilityType
        });
    }

    return data;
}
