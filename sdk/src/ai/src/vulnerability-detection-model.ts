import * as tf from '@tensorflow/tfjs-node';
import { MLModel } from './ml-model';
import { VulnerabilityType } from '../../types';

/**
* Output interface for vulnerability predictions including type and confidence
*/
export interface VulnerabilityOutput {
type: VulnerabilityType | null;
confidence: number;
details?: string;
}

/**
* Model configuration for vulnerability detection
*/
export interface VulnerabilityModelConfig {
hiddenLayers?: number[];
learningRate?: number;
epochs?: number;
batchSize?: number;
}

/**
* ML model specialized for detecting vulnerabilities in smart contract code
* Extends base MLModel with vulnerability-specific functionality
*/
export class VulnerabilityDetectionModel extends MLModel {
private readonly vulnTypes: VulnerabilityType[];
private model: tf.LayersModel;
private readonly config: VulnerabilityModelConfig;

/**
* Initialize vulnerability detection model with configuration
* @param config - Model configuration parameters
*/
constructor(config: VulnerabilityModelConfig = {}) {
    super();
    this.config = {
    hiddenLayers: config.hiddenLayers || [64, 32],
    learningRate: config.learningRate || 0.001,
    epochs: config.epochs || 50,
    batchSize: config.batchSize || 32
    };
    this.vulnTypes = Object.values(VulnerabilityType);
    this.initializeModel();
}

/**
* Set up the TensorFlow model architecture
*/
private initializeModel(): void {
    const model = tf.sequential();
    
    // Input layer
    model.add(tf.layers.dense({
    units: this.config.hiddenLayers[0],
    activation: 'relu',
    inputShape: [128] // Feature vector size
    }));

    // Hidden layers
    for (let i = 1; i < this.config.hiddenLayers.length; i++) {
    model.add(tf.layers.dense({
        units: this.config.hiddenLayers[i],
        activation: 'relu'
    }));
    model.add(tf.layers.dropout({ rate: 0.2 }));
    }

    // Output layer - one unit per vulnerability type
    model.add(tf.layers.dense({
    units: this.vulnTypes.length,
    activation: 'softmax'
    }));

    model.compile({
    optimizer: tf.train.adam(this.config.learningRate),
    loss: 'categoricalCrossentropy',
    metrics: ['accuracy']
    });

    this.model = model;
}

/**
* Train model on vulnerability dataset
* @param features - Array of feature vectors
* @param labels - Array of vulnerability type labels
*/
async train(features: number[][], labels: number[]): Promise<void> {
    tf.util.assert(
    features.length === labels.length,
    'Features and labels must have same length'
    );

    const xs = tf.tensor2d(features);
    const ys = tf.oneHot(tf.tensor1d(labels, 'int32'), this.vulnTypes.length);

    await this.model.fit(xs, ys, {
    epochs: this.config.epochs,
    batchSize: this.config.batchSize,
    validationSplit: 0.2,
    callbacks: {
        onEpochEnd: (epoch, logs) => {
        console.log(`Epoch ${epoch}: loss = ${logs?.loss.toFixed(4)}`);
        }
    }
    });

    xs.dispose();
    ys.dispose();
}

/**
* Predict vulnerability type and confidence for input features
* @param features - Input feature vector
* @returns Prediction result with vulnerability type and confidence
*/
async predict(features: number[]): Promise<VulnerabilityOutput> {
    if (!this.model) {
    throw new Error('Model not initialized');
    }

    const input = tf.tensor2d([features]);
    const prediction = this.model.predict(input) as tf.Tensor;
    
    const probabilities = await prediction.array() as number[][];
    const maxProbIndex = probabilities[0].indexOf(Math.max(...probabilities[0]));
    const confidence = probabilities[0][maxProbIndex];

    input.dispose();
    prediction.dispose();

    // Only return vulnerability type if confidence exceeds threshold
    if (confidence > 0.5) {
    return {
        type: this.vulnTypes[maxProbIndex],
        confidence,
        details: `Detected ${this.vulnTypes[maxProbIndex]} with ${(confidence * 100).toFixed(1)}% confidence`
    };
    }

    return {
    type: null,
    confidence: 0,
    details: 'No vulnerability detected with high confidence'
    };
}

/**
* Save model weights to file
* @param path - File path to save model
*/
async save(path: string): Promise<void> {
    await this.model.save(`file://${path}`);
}

/**
* Load model weights from file
* @param path - File path to load model from
*/
async load(path: string): Promise<void> {
    this.model = await tf.loadLayersModel(`file://${path}`);
}

/**
* Clean up model resources
*/
async cleanup(): Promise<void> {
    if (this.model) {
    this.model.dispose();
    }
    tf.disposeVariables();
}
}

