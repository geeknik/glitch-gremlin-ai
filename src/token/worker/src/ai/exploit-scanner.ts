import { 
Connection, 
PublicKey, 
Transaction, 
Keypair,
TransactionInstruction,
SystemProgram,
LAMPORTS_PER_SOL,
SendTransactionError
} from '@solana/web3.js';

interface ChaosParams {
  duration: number;
  intensity: number;
}

interface Finding {
  type: string;
  details: string;
}

enum VulnerabilityType {
  REENTRANCY = 'REENTRANCY',
  ARITHMETIC_OVERFLOW = 'ARITHMETIC_OVERFLOW',
  ACCESS_CONTROL = 'ACCESS_CONTROL'
}

interface Logger {
  info: (msg: string) => void;
  error: (msg: string) => void;
}
import * as tf from '@tensorflow/tfjs-node';
import { ScoringSystem } from './scoring';
import { VulnerabilityDetectionModel } from './ml-model';

export class ExploitScanner {
    private readonly mlModel: VulnerabilityDetectionModel;
    private readonly connection: Connection;
    private readonly logger: Logger;
    
    constructor(
        connection: Connection,
        mlModel: VulnerabilityDetectionModel,
        logger: Logger
    ) {
        this.connection = connection;
        this.mlModel = mlModel;
        this.logger = logger;
    }
    private readonly KNOWN_VULNERABILITIES = [
        'reentrancy',
        'arithmetic-overflow',
        'access-control',
        'race-condition', 
        'instruction-injection',
        'account-confusion',
        'signer-authorization',
        'pda-validation',
        'clock-manipulation',
        'lamport-drain'
    ];

    private readonly VULNERABILITY_PATTERNS = {
        'reentrancy': /invoke_signed|CPI|cross_program/i,
        'arithmetic-overflow': /checked_add|checked_sub|overflow/i,
        'access-control': /is_signer|is_writable|owner/i,
        'pda-validation': /find_program_address|create_program_address/i,
        'signer-authorization': /verify_signer|verify_authority/i
    };

    async analyzeStatic(programId: string): Promise<{
        findings: string[];
        riskScore: number;
        mlPredictions?: Array<{
            type: VulnerabilityType;
            confidence: number;
        }>;
    }> {
        const findings: string[] = [];
        let riskScore = 0;

        try {
            // Fetch program data
            const programInfo = await this.connection.getProgramAccounts(
                new PublicKey(programId),
                { encoding: 'base64' }
            );

            // Analyze program bytecode
            for (const account of programInfo) {
                const code = account.account.data.toString();
                
                // Check for known vulnerability patterns
                for (const [vulnType, pattern] of Object.entries(this.VULNERABILITY_PATTERNS)) {
                    if (pattern.test(code)) {
                        findings.push(`Potential ${vulnType} vulnerability detected`);
                        riskScore += 10;
                    }
                }

                // Check for unsafe math operations
                if (!/checked_add|checked_sub|checked_mul/.test(code)) {
                    findings.push('Unchecked arithmetic operations detected');
                    riskScore += 15;
                }

                // Check for proper PDA validation
                if (code.includes('create_program_address') && 
                    !code.includes('find_program_address')) {
                    findings.push('Potential PDA validation issue');
                    riskScore += 20;
                }
            }

            // Normalize risk score
            riskScore = Math.min(100, riskScore);

            // Get ML predictions
            const features = this.extractFeatures(Array.from(programInfo));
            const mlPredictions = await this.mlModel.predict(features);

            return { 
                findings, 
                riskScore,
                mlPredictions: [mlPredictions]
            };
        } catch (error) {
            this.logger.error(`Static analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
            throw error;
        }
    }

    async runFullScan(
        programId: string,
        params: ChaosParams
    ): Promise<{
        success: boolean;
        findings: string[];
        metrics: {
            totalTransactions: number;
            errorRate: number;
            avgLatency: number;
        };
    }> {
        const findings: string[] = [];
        let totalTx = 0;
        let errors = 0;
        let totalLatency = 0;

        // Test for each known vulnerability type
        for (const vulnType of this.KNOWN_VULNERABILITIES) {
            const result = await this.testVulnerability(programId, vulnType);
            if (result.found) {
                findings.push(`${vulnType}: ${result.details}`);
            }
            totalTx += result.transactions;
            errors += result.errors;
            totalLatency += result.latency;
        }

        return {
            success: true,
            findings,
            metrics: {
                totalTransactions: totalTx,
                errorRate: errors / totalTx,
                avgLatency: totalLatency / totalTx
            }
        };
    }

    private async testVulnerability(
        programId: string,
        vulnType: string
    ): Promise<{
        found: boolean;
        details: string;
        transactions: number;
        errors: number;
        latency: number;
    }> {
        const startTime = Date.now();
        let transactions = 0;
        let errors = 0;

        try {
            switch (vulnType) {
                case 'reentrancy':
                    return await this.testReentrancy(programId);
                case 'arithmetic-overflow':
                    return await this.testArithmeticOverflow(programId);
                case 'access-control':
                    return await this.testAccessControl(programId);
                case 'race-condition':
                    return await this.testRaceCondition(programId);
                default:
                    return {
                        found: false,
                        details: `Test not implemented for ${vulnType}`,
                        transactions,
                        errors,
                        latency: Date.now() - startTime
                    };
            }
        } catch (error) {
            this.logger.error(`Vulnerability test failed for ${vulnType}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return {
                found: false,
                details: `Test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
                transactions,
                errors: errors + 1,
                latency: Date.now() - startTime
            };
        }
    }

    private async testReentrancy(programId: string): Promise<{
        found: boolean;
        details: string;
        transactions: number;
        errors: number;  
        latency: number;
    }> {
        const startTime = Date.now();
        let transactions = 0;
        let errors = 0;

        try {
            // Create test accounts
            const testAccount = Keypair.generate();
            const attackerAccount = Keypair.generate();

            // Fund test accounts
            const fundTx = new Transaction().add(
                SystemProgram.transfer({
                    fromPubkey: Keypair.generate().publicKey, // Use a generated keypair instead
                    toPubkey: testAccount.publicKey,
                    lamports: LAMPORTS_PER_SOL
                })
            );

            try {
                await this.connection.sendTransaction(fundTx, []);
                transactions++;
            } catch (error) {
                this.logger.error(`Failed to fund test account: ${error instanceof Error ? error.message : 'Unknown error'}`);
                errors++;
            }

            // Test reentrancy by creating nested CPI calls
            const ix1 = new TransactionInstruction({
                keys: [
                    {pubkey: testAccount.publicKey, isSigner: true, isWritable: true},
                    {pubkey: attackerAccount.publicKey, isSigner: false, isWritable: true}
                ],
                programId: new PublicKey(programId),
                data: Buffer.from('test-reentrancy')
            });

            const ix2 = new TransactionInstruction({
                keys: [
                    {pubkey: attackerAccount.publicKey, isSigner: true, isWritable: true},
                    {pubkey: testAccount.publicKey, isSigner: false, isWritable: true} 
                ],
                programId: new PublicKey(programId),
                data: Buffer.from('reenter')
            });

            const tx = new Transaction().add(ix1).add(ix2);
            
            try {
                await this.connection.sendTransaction(tx, [testAccount, attackerAccount]);
                transactions++;
            } catch (error) {
                if (error instanceof SendTransactionError) {
                    // Check if error indicates reentrancy
                    const found = error.logs?.some(log => 
                        log.includes('recursive call detected') ||
                        log.includes('reentrant call') ||
                        log.includes('instruction already in progress')
                    );

                    return {
                        found,
                        details: found ? 'Reentrancy vulnerability detected through error analysis' : 'No reentrancy found',
                        transactions,
                        errors: errors + 1,
                        latency: Date.now() - startTime
                    };
                }
                errors++;
            }

            // Final simulation to analyze program behavior
            const simResult = await this.connection.simulateTransaction(tx);
            transactions++;

            const found = this.analyzeReentrancyResult(simResult.value);

            return {
                found,
                details: found ? 'Reentrancy vulnerability detected' : 'No reentrancy found',
                transactions,
                errors,
                latency: Date.now() - startTime
            };

        } catch (error) {
            this.logger.error(`Reentrancy test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return {
                found: false,
                details: `Reentrancy test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
                transactions,
                errors: errors + 1, 
                latency: Date.now() - startTime
            };
        }
    }

    private async testArithmeticOverflow(programId: string): Promise<{
        found: boolean;
        details: string;
        transactions: number;
        errors: number;
        latency: number;
    }> {
        const startTime = Date.now();
        let transactions = 0;
        let errors = 0;

        try {
            const testAccount = Keypair.generate();

            // Test with large numbers to trigger potential overflows
            const ix = new TransactionInstruction({
                keys: [
                    {pubkey: testAccount.publicKey, isSigner: true, isWritable: true}
                ],
                programId: new PublicKey(programId),
                data: Buffer.from([
                    255, 255, 255, 255, // Max u32
                    0, 0, 0, 0, 0, 0, 0, 0, // Large amount
                ])
            });

            const tx = new Transaction().add(ix);

            try {
                const result = await this.connection.simulateTransaction(tx);
                transactions++;

                const found = result.value.logs?.some(log =>
                    log.includes('overflow') ||
                    log.includes('arithmetic error') ||
                    log.includes('calculation failed')
                );

                return {
                    found,
                    details: found ? 'Arithmetic overflow vulnerability detected' : 'No arithmetic vulnerabilities found',
                    transactions,
                    errors,
                    latency: Date.now() - startTime
                };

            } catch (error) {
                if (error instanceof SendTransactionError) {
                    const isOverflow = error.logs?.some(log =>
                        log.includes('overflow') ||
                        log.includes('arithmetic error')
                    );

                    if (isOverflow) {
                        return {
                            found: true,
                            details: 'Arithmetic overflow vulnerability detected through error',
                            transactions,
                            errors: errors + 1,
                            latency: Date.now() - startTime
                        };
                    }
                }
                errors++;
            }

            return {
                found: false,
                details: 'No arithmetic vulnerabilities found',
                transactions,
                errors,
                latency: Date.now() - startTime
            };

        } catch (error) {
            this.logger.error(`Arithmetic overflow test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return {
                found: false,
                details: `Arithmetic test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
                transactions,
                errors: errors + 1,
                latency: Date.now() - startTime
            };
        }
    }

    private async testAccessControl(programId: string): Promise<{
        found: boolean;
        details: string;
        transactions: number;
        errors: number;
        latency: number;
    }> {
        const startTime = Date.now();
        let transactions = 0;
        let errors = 0;

        try {
            // Create test accounts
            const authorizedAccount = Keypair.generate();
            const unauthorizedAccount = Keypair.generate();

            // Test unauthorized access
            const ix = new TransactionInstruction({
                keys: [
                    {pubkey: unauthorizedAccount.publicKey, isSigner: true, isWritable: false},
                    {pubkey: authorizedAccount.publicKey, isSigner: false, isWritable: true}
                ],
                programId: new PublicKey(programId),
                data: Buffer.from('admin-operation')
            });

            const tx = new Transaction().add(ix);

            try {
                const result = await this.connection.simulateTransaction(tx);
                transactions++;

                const found = !result.value.logs?.some(log =>
                    log.includes('missing required signature') ||
                    log.includes('unauthorized') ||
                    log.includes('permission denied')
                );

                return {
                    found,
                    details: found ? 'Access control vulnerability detected' : 'Access controls appear secure',
                    transactions,
                    errors,
                    latency: Date.now() - startTime
                };

            } catch (error) {
                // Expected error for proper access control
                if (error instanceof SendTransactionError &&
                    error.logs?.some(log => log.includes('unauthorized'))) {
                    return {
                        found: false,
                        details: 'Access controls working as expected',
                        transactions,
                        errors: errors + 1,
                        latency: Date.now() - startTime
                    };
                }
                errors++;
            }

            return {
                found: false,
                details: 'Access control test inconclusive',
                transactions, 
                errors,
                latency: Date.now() - startTime
            };

        } catch (error) {
            this.logger.error(`Access control test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return {
                found: false,
                details: `Access control test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
                transactions,
                errors: errors + 1,
                latency: Date.now() - startTime
            };
        }
    }

    private async testRaceCondition(programId: string): Promise<{
        found: boolean;
        details: string;
        transactions: number;
        errors: number;
        latency: number;
    }> {
        const startTime = Date.now();
        let transactions = 0;
        let errors = 0;

        try {
            const testAccount = Keypair.generate();
            const competingAccount = Keypair.generate();

            // Create competing transactions
            const ix1 = new TransactionInstruction({
                keys: [
                    {pubkey: testAccount.publicKey, isSigner: true, isWritable: true}
                ],
                programId: new PublicKey(programId),
                data: Buffer.from('compete-for-resource')
            });

            const ix2 = new TransactionInstruction({
                keys: [
                    {pubkey: competingAccount.publicKey, isSigner: true, isWritable: true}
                ],
                programId: new PublicKey(programId),
                data: Buffer.from('compete-for-resource')
            });

            const tx1 = new Transaction().add(ix1);
            const tx2 = new Transaction().add(ix2);

            // Send transactions nearly simultaneously
            try {
                const [sig1, sig2] = await Promise.all([
                    this.connection.sendTransaction(tx1, [testAccount]),
                    this.connection.sendTransaction(tx2, [competingAccount])
                ]);
                transactions += 2;

                // Check results
                const [result1, result2] = await Promise.all([
                    this.connection.getParsedConfirmedTransaction(sig1),
                    this.connection.getParsedConfirmedTransaction(sig2)
                ]);

                const found = result1 && result2 && 
                    result1.meta?.logMessages?.some(log => 
                        log.includes('state mismatch') ||
                        log.includes('invalid state transition') ||
                        log.includes('concurrent access detected')
                    );

                return {
                    found,
                    details: found ? 'Race condition vulnerability detected' : 'No race conditions found',
                    transactions,
                    errors,
                    latency: Date.now() - startTime
                };

            } catch (error) {
                errors += 2;
                this.logger.error(`Race condition test transactions failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }

            return {
                found: false,
                details: 'Race condition test inconclusive',
                transactions,
                errors,
                latency: Date.now() - startTime
            };

        } catch (error) {
            this.logger.error(`Race condition test failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return {
                found: false,
                details: `Race condition test failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
                transactions,
                errors: errors + 1,
                latency: Date.now() - startTime
            };
        }
    }
    private extractFeatures(programInfo: any[]): number[] {
        // Extract numerical features from program info
        const features = [
            programInfo.length, // Number of accounts
            this.countPatternMatches(programInfo, /invoke_signed|CPI/), // CPI count
            this.countPatternMatches(programInfo, /checked_add|checked_sub/), // Safe math ops
            this.countPatternMatches(programInfo, /is_signer|is_writable/), // Access checks
            this.countPatternMatches(programInfo, /find_program_address/), // PDA usage
            this.countPatternMatches(programInfo, /verify/), // Verification calls
            programInfo.reduce((sum, acc) => sum + acc.account.data.length, 0), // Total data size
            this.countPatternMatches(programInfo, /error/i), // Error handling
            this.countPatternMatches(programInfo, /assert/), // Assertions
            this.countPatternMatches(programInfo, /lock|mutex/) // Synchronization
        ];
        return features;
    }

    private countPatternMatches(programInfo: any[], pattern: RegExp): number {
        return programInfo.reduce((count, acc) => {
            const matches = acc.account.data.toString().match(pattern);
            return count + (matches ? matches.length : 0);
        }, 0);
    }
}
