import * as tf from '@tensorflow/tfjs-node';
import { VulnerabilityType } from './types.js';
import { VulnerabilityDetectionModel, PredictionResult, TrainingResult, MLConfig } from './types.js';
import { LayersModel } from '@tensorflow/tfjs-node';

export class VulnerabilityDetector implements VulnerabilityDetectionModel {
    private _model: LayersModel | null = null;
    private readonly vulnTypes: string[];
    public readonly config: MLConfig = {
        inputShape: [100],
        hiddenLayers: [64, 32],
        learningRate: 0.001,
        epochs: 10,
        batchSize: 32
    };

    constructor() {
        this.vulnTypes = ['Reentrancy', 'ArithmeticOverflow', 'AccessControl', 'RaceCondition', 
            'InstructionInjection', 'AccountConfusion', 'SignerAuthorization', 'DataValidation', 
            'ClockManipulation', 'LamportDrain'];
    }

    get model(): LayersModel {
        if (!this._model) {
            throw new Error('Model not initialized');
        }
        return this._model;
    }

    set model(value: LayersModel) {
        this._model = value;
    }

    async initialize(): Promise<void> {
        if (!this._model) {
            const model = tf.sequential();
            model.add(tf.layers.dense({
                units: 64,
                activation: 'relu',
                inputShape: this.config.inputShape
            }));
            model.add(tf.layers.dense({
                units: 32,
                activation: 'relu'
            }));
            model.add(tf.layers.dense({
                units: this.vulnTypes.length,
                activation: 'softmax'
            }));

            model.compile({
                optimizer: tf.train.adam(this.config.learningRate),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            this._model = model as unknown as LayersModel;
        }
    }

    async ensureInitialized(): Promise<void> {
        if (!this._model) {
            await this.initialize();
        }
    }

    async train(features: number[][], labels: number[][]): Promise<TrainingResult> {
        await this.ensureInitialized();

        const xs = tf.tensor2d(features);
        const ys = tf.tensor2d(labels);

        const startTime = Date.now();
        const history = await this.model.fit(xs, ys, {
            epochs: this.config.epochs,
            batchSize: this.config.batchSize,
            validationSplit: 0.2,
            shuffle: true
        });

        xs.dispose();
        ys.dispose();

        const lastEpoch = history.history.acc.length - 1;
        return {
            accuracy: Number(history.history.acc[lastEpoch]),
            loss: Number(history.history.loss[lastEpoch]),
            epochs: history.epoch.length,
            epoch: lastEpoch,
            validationLoss: history.history.val_loss ? Number(history.history.val_loss[lastEpoch]) : undefined,
            validationAccuracy: history.history.val_acc ? Number(history.history.val_acc[lastEpoch]) : undefined
        };
    }

    async predict(features: number[][]): Promise<PredictionResult> {
        await this.ensureInitialized();

        const xs = tf.tensor2d(features);
        const predictions = this.model.predict(xs) as tf.Tensor;
        const values = await predictions.array() as number[][];
        const maxIndex = values[0].indexOf(Math.max(...values[0]));
        const confidence = values[0][maxIndex];

        xs.dispose();
        predictions.dispose();

        const vulnerabilityType = this.vulnTypes[maxIndex] as VulnerabilityType;
        if (!vulnerabilityType) {
            throw new Error('Invalid prediction index');
        }

        return {
            vulnerabilityType,
            confidence,
            timestamp: new Date(),
            modelVersion: '1.0.0',
            details: this.getVulnerabilityDetails(vulnerabilityType)
        };
    }

    async detectVulnerability(features: number[][]): Promise<VulnerabilityType> {
        const prediction = await this.predict(features);
        return prediction.vulnerabilityType;
    }

    async getConfidenceScore(features: number[][]): Promise<number> {
        const prediction = await this.predict(features);
        return prediction.confidence;
    }

    getVulnerabilityDetails(type: VulnerabilityType): string {
        switch (type) {
            case VulnerabilityType.Reentrancy:
                return 'Potential reentrancy vulnerability detected. Consider implementing checks-effects-interactions pattern.';
            case VulnerabilityType.ArithmeticOverflow:
                return 'Potential arithmetic overflow detected. Consider using checked math operations.';
            case VulnerabilityType.AccessControl:
                return 'Potential access control vulnerability detected. Review permission checks.';
            case VulnerabilityType.RaceCondition:
                return 'Potential race condition detected. Consider implementing proper synchronization.';
            case VulnerabilityType.InstructionInjection:
                return 'Potential instruction injection vulnerability detected. Validate all instruction data.';
            case VulnerabilityType.AccountConfusion:
                return 'Potential account confusion detected. Implement strict account validation.';
            case VulnerabilityType.SignerAuthorization:
                return 'Potential signer authorization issue detected. Verify all required signers.';
            case VulnerabilityType.DataValidation:
                return 'Potential data validation vulnerability detected. Implement comprehensive input validation.';
            case VulnerabilityType.ClockManipulation:
                return 'Potential clock manipulation vulnerability detected. Use secure time sources.';
            case VulnerabilityType.LamportDrain:
                return 'Potential lamport drain vulnerability detected. Implement proper fee handling.';
            default:
                return 'Unknown vulnerability type detected. Review code for potential security issues.';
        }
    }

    async save(path: string): Promise<void> {
        await this.ensureInitialized();
        await this.model.save(`file://${path}`);
    }

    async load(path: string): Promise<void> {
        const loadedModel = await tf.loadLayersModel(`file://${path}`);
        this.model = loadedModel as unknown as LayersModel;
    }

    async dispose(): Promise<void> {
        if (this._model) {
            this._model.dispose();
            this._model = null;
        }
    }

    async cleanup(): Promise<void> {
        await this.dispose();
    }
} 