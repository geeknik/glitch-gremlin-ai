import * as tf from '@tensorflow/tfjs-node';
import { SecurityLevel, VulnerabilityType, VulnerabilityInfo } from '../../types.js';
import { VulnerabilityDetectionModel, PredictionResult, TrainingResult, MLConfig } from './types.js';
import { LayersModel } from '@tensorflow/tfjs-node';

export class VulnerabilityDetector implements VulnerabilityDetectionModel {
    private _model: LayersModel | null = null;
    private vulnTypes: VulnerabilityType[] = [
        VulnerabilityType.Reentrancy,
        VulnerabilityType.AccessControl,
        VulnerabilityType.ArithmeticOverflow,
        VulnerabilityType.PDASafety,
        VulnerabilityType.CPISafety,
        VulnerabilityType.SignerAuthorization,
        VulnerabilityType.AuthorityCheck,
        VulnerabilityType.DataValidation,
        VulnerabilityType.AccountValidation
    ];
    public readonly config: MLConfig = {
        inputShape: [100],
        hiddenLayers: [64, 32],
        learningRate: 0.001,
        epochs: 10,
        batchSize: 32
    };

    constructor() {
        // Initialize any other necessary properties
    }

    get model(): LayersModel {
        if (!this._model) {
            throw new Error('Model not initialized');
        }
        return this._model;
    }

    set model(value: LayersModel) {
        this._model = value;
    }

    async initialize(): Promise<void> {
        if (!this._model) {
            const model = tf.sequential();
            model.add(tf.layers.dense({
                units: 64,
                activation: 'relu',
                inputShape: this.config.inputShape
            }));
            model.add(tf.layers.dense({
                units: 32,
                activation: 'relu'
            }));
            model.add(tf.layers.dense({
                units: this.vulnTypes.length,
                activation: 'softmax'
            }));

            model.compile({
                optimizer: tf.train.adam(this.config.learningRate),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            this._model = model as unknown as LayersModel;
        }
    }

    async ensureInitialized(): Promise<void> {
        if (!this._model) {
            await this.initialize();
        }
    }

    async train(features: number[][], labels: number[][]): Promise<TrainingResult> {
        await this.ensureInitialized();

        const xs = tf.tensor2d(features);
        const ys = tf.tensor2d(labels);

        const startTime = Date.now();
        const history = await this.model.fit(xs, ys, {
            epochs: this.config.epochs,
            batchSize: this.config.batchSize,
            validationSplit: 0.2,
            shuffle: true
        });

        xs.dispose();
        ys.dispose();

        const lastEpoch = history.history.acc.length - 1;
        return {
            accuracy: Number(history.history.acc[lastEpoch]),
            loss: Number(history.history.loss[lastEpoch]),
            epochs: history.epoch.length,
            epoch: lastEpoch,
            validationLoss: history.history.val_loss ? Number(history.history.val_loss[lastEpoch]) : undefined,
            validationAccuracy: history.history.val_acc ? Number(history.history.val_acc[lastEpoch]) : undefined
        };
    }

    async predict(features: number[][]): Promise<PredictionResult> {
        await this.ensureInitialized();

        const xs = tf.tensor2d(features);
        const predictions = this.model.predict(xs) as tf.Tensor;
        const values = await predictions.array() as number[][];
        const maxIndex = values[0].indexOf(Math.max(...values[0]));
        const confidence = values[0][maxIndex];

        xs.dispose();
        predictions.dispose();

        const vulnerabilityType = this.vulnTypes[maxIndex] as VulnerabilityType;
        if (!vulnerabilityType) {
            throw new Error('Invalid prediction index');
        }

        return {
            vulnerabilityType,
            confidence,
            timestamp: new Date(),
            modelVersion: '1.0.0',
            details: this.getVulnerabilityDetails(vulnerabilityType)
        };
    }

    async detectVulnerability(features: number[][]): Promise<VulnerabilityType> {
        const prediction = await this.predict(features);
        return prediction.vulnerabilityType;
    }

    async getConfidenceScore(features: number[][]): Promise<number> {
        const prediction = await this.predict(features);
        return prediction.confidence;
    }

    getVulnerabilityDetails(type: VulnerabilityType): string {
        const info = this.getVulnerabilityInfo(type);
        return `${info.name}: ${info.description}\nRecommendation: ${info.recommendation}`;
    }

    private getVulnerabilityInfo(vulnType: VulnerabilityType): VulnerabilityInfo {
        switch (vulnType) {
            case VulnerabilityType.Reentrancy:
                return {
                    id: 'REENTRANCY',
                    name: 'Reentrancy Vulnerability',
                    description: 'Program is vulnerable to reentrancy attacks',
                    severity: SecurityLevel.CRITICAL,
                    confidence: 0.9,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Cross-program invocation detected without proper guards'],
                    recommendation: 'Implement reentrancy guards and check account states',
                    vulnerabilityType: VulnerabilityType.Reentrancy,
                    details: {
                        expectedValue: 'No reentrancy',
                        actualValue: 'Potential reentrancy detected',
                        location: 'Cross-program invocation',
                        impact: 'Critical - Potential unauthorized re-entry',
                        likelihood: SecurityLevel.HIGH
                    }
                };
            case VulnerabilityType.AccessControl:
                return {
                    id: 'ACCESS_CONTROL',
                    name: 'Access Control Vulnerability', 
                    description: 'Insufficient access controls on critical operations',
                    severity: SecurityLevel.HIGH,
                    confidence: 0.85,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Missing authority checks on privileged operations'],
                    recommendation: 'Add proper authority validation checks',
                    vulnerabilityType: VulnerabilityType.AccessControl,
                    details: {
                        expectedValue: 'Authority check present',
                        actualValue: 'Missing authority check',
                        location: 'Privileged operation',
                        impact: 'Critical - Unauthorized access possible',
                        likelihood: SecurityLevel.HIGH
                    }
                };
            case VulnerabilityType.ArithmeticOverflow:
                return {
                    id: 'ARITHMETIC_OVERFLOW',
                    name: 'Arithmetic Overflow Vulnerability',
                    description: 'Potential arithmetic overflow detected',
                    severity: SecurityLevel.HIGH,
                    confidence: 0.8,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Unchecked arithmetic operation detected'],
                    recommendation: 'Use checked math operations',
                    vulnerabilityType: VulnerabilityType.ArithmeticOverflow,
                    details: {
                        expectedValue: 'Checked arithmetic',
                        actualValue: 'Unchecked arithmetic',
                        location: 'Math operation',
                        impact: 'Critical - Potential overflow',
                        likelihood: SecurityLevel.MEDIUM
                    }
                };
            case VulnerabilityType.PDASafety:
                return {
                    id: 'PDA_SAFETY',
                    name: 'PDA Safety Vulnerability',
                    description: 'PDA safety validation issue detected',
                    severity: SecurityLevel.HIGH,
                    confidence: 0.8,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Missing PDA validation'],
                    recommendation: 'Implement proper PDA validation',
                    vulnerabilityType: VulnerabilityType.PDASafety,
                    details: {
                        expectedValue: 'PDA validation implemented',
                        actualValue: 'PDA validation not implemented',
                        location: 'PDA usage',
                        impact: 'Critical - Potential data integrity issues',
                        likelihood: SecurityLevel.HIGH
                    }
                };
            case VulnerabilityType.CPISafety:
                return {
                    id: 'CPI_SAFETY',
                    name: 'CPI Safety Vulnerability',
                    description: 'Cross-program invocation safety issue detected',
                    severity: SecurityLevel.HIGH,
                    confidence: 0.8,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Missing CPI target validation'],
                    recommendation: 'Validate CPI targets',
                    vulnerabilityType: VulnerabilityType.CPISafety,
                    details: {
                        expectedValue: 'CPI targets validated',
                        actualValue: 'CPI targets not validated',
                        location: 'CPI usage',
                        impact: 'Critical - Potential security issues',
                        likelihood: SecurityLevel.HIGH
                    }
                };
            case VulnerabilityType.SignerAuthorization:
                return {
                    id: 'SIGNER_AUTHORIZATION',
                    name: 'Signer Authorization Vulnerability',
                    description: 'Potential signer authorization issue detected',
                    severity: SecurityLevel.HIGH,
                    confidence: 0.8,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Missing signer verification'],
                    recommendation: 'Verify all required signers',
                    vulnerabilityType: VulnerabilityType.SignerAuthorization,
                    details: {
                        expectedValue: 'All required signers verified',
                        actualValue: 'Missing signer verification',
                        location: 'Signer usage',
                        impact: 'Critical - Potential unauthorized access',
                        likelihood: SecurityLevel.HIGH
                    }
                };
            case VulnerabilityType.AuthorityCheck:
                return {
                    id: 'AUTHORITY_CHECK',
                    name: 'Authority Check Vulnerability',
                    description: 'Insufficient authority validation detected',
                    severity: SecurityLevel.HIGH,
                    confidence: 0.8,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Missing authority checks'],
                    recommendation: 'Add comprehensive authority checks',
                    vulnerabilityType: VulnerabilityType.AuthorityCheck,
                    details: {
                        expectedValue: 'Comprehensive authority checks',
                        actualValue: 'Inadequate authority checks',
                        location: 'Authority usage',
                        impact: 'Critical - Potential unauthorized access',
                        likelihood: SecurityLevel.HIGH
                    }
                };
            case VulnerabilityType.DataValidation:
                return {
                    id: 'DATA_VALIDATION',
                    name: 'Data Validation Vulnerability',
                    description: 'Potential data validation vulnerability detected',
                    severity: SecurityLevel.HIGH,
                    confidence: 0.8,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Missing input validation'],
                    recommendation: 'Implement comprehensive input validation',
                    vulnerabilityType: VulnerabilityType.DataValidation,
                    details: {
                        expectedValue: 'Comprehensive input validation',
                        actualValue: 'Inadequate input validation',
                        location: 'Input processing',
                        impact: 'Critical - Potential data integrity issues',
                        likelihood: SecurityLevel.HIGH
                    }
                };
            case VulnerabilityType.AccountValidation:
                return {
                    id: 'ACCOUNT_VALIDATION',
                    name: 'Account Validation Vulnerability',
                    description: 'Account validation issue detected',
                    severity: SecurityLevel.HIGH,
                    confidence: 0.8,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: ['Missing account validation'],
                    recommendation: 'Implement proper account validation',
                    vulnerabilityType: VulnerabilityType.AccountValidation,
                    details: {
                        expectedValue: 'Proper account validation',
                        actualValue: 'Inadequate account validation',
                        location: 'Account usage',
                        impact: 'Critical - Potential unauthorized access',
                        likelihood: SecurityLevel.HIGH
                    }
                };
            default:
                return {
                    id: 'UNKNOWN',
                    name: 'Unknown Vulnerability',
                    description: 'An unknown vulnerability was detected',
                    severity: SecurityLevel.LOW,
                    confidence: 0.5,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    evidence: [],
                    recommendation: 'Review code for potential security issues',
                    vulnerabilityType: VulnerabilityType.None,
                    details: {
                        expectedValue: 'No vulnerability',
                        actualValue: 'Unknown issue detected',
                        location: 'Unknown',
                        impact: 'Unknown',
                        likelihood: SecurityLevel.LOW
                    }
                };
        }
    }

    async save(path: string): Promise<void> {
        await this.ensureInitialized();
        await this.model.save(`file://${path}`);
    }

    async load(path: string): Promise<void> {
        const loadedModel = await tf.loadLayersModel(`file://${path}`);
        this.model = loadedModel as unknown as LayersModel;
    }

    async dispose(): Promise<void> {
        if (this._model) {
            this._model.dispose();
            this._model = null;
        }
    }

    async cleanup(): Promise<void> {
        await this.dispose();
    }
} 