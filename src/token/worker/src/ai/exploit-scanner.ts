import { PublicKey } from '@solana/web3.js';
import { ChaosParams } from '../../types';
import * as tf from '@tensorflow/tfjs-node';
import { ScoringSystem } from './scoring';

export class ExploitScanner {
    private readonly KNOWN_VULNERABILITIES = [
        'reentrancy',
        'arithmetic-overflow',
        'access-control',
        'race-condition', 
        'instruction-injection',
        'account-confusion',
        'signer-authorization',
        'pda-validation',
        'clock-manipulation',
        'lamport-drain'
    ];

    private readonly VULNERABILITY_PATTERNS = {
        'reentrancy': /invoke_signed|CPI|cross_program/i,
        'arithmetic-overflow': /checked_add|checked_sub|overflow/i,
        'access-control': /is_signer|is_writable|owner/i,
        'pda-validation': /find_program_address|create_program_address/i,
        'signer-authorization': /verify_signer|verify_authority/i
    };

    async analyzeStatic(programId: string): Promise<{
        findings: string[];
        riskScore: number;
    }> {
        const findings: string[] = [];
        let riskScore = 0;

        try {
            // Fetch program data
            const programInfo = await this.connection.getProgramAccounts(
                new PublicKey(programId),
                { encoding: 'base64' }
            );

            // Analyze program bytecode
            for (const account of programInfo) {
                const code = account.account.data.toString();
                
                // Check for known vulnerability patterns
                for (const [vulnType, pattern] of Object.entries(this.VULNERABILITY_PATTERNS)) {
                    if (pattern.test(code)) {
                        findings.push(`Potential ${vulnType} vulnerability detected`);
                        riskScore += 10;
                    }
                }

                // Check for unsafe math operations
                if (!/checked_add|checked_sub|checked_mul/.test(code)) {
                    findings.push('Unchecked arithmetic operations detected');
                    riskScore += 15;
                }

                // Check for proper PDA validation
                if (code.includes('create_program_address') && 
                    !code.includes('find_program_address')) {
                    findings.push('Potential PDA validation issue');
                    riskScore += 20;
                }
            }

            // Normalize risk score
            riskScore = Math.min(100, riskScore);

            return { findings, riskScore };
        } catch (error) {
            this.logger.error('Static analysis failed:', error);
            throw error;
        }
    }

    async runFullScan(
        programId: string,
        params: ChaosParams
    ): Promise<{
        success: boolean;
        findings: string[];
        metrics: {
            totalTransactions: number;
            errorRate: number;
            avgLatency: number;
        };
    }> {
        const findings: string[] = [];
        let totalTx = 0;
        let errors = 0;
        let totalLatency = 0;

        // Test for each known vulnerability type
        for (const vulnType of this.KNOWN_VULNERABILITIES) {
            const result = await this.testVulnerability(programId, vulnType);
            if (result.found) {
                findings.push(`${vulnType}: ${result.details}`);
            }
            totalTx += result.transactions;
            errors += result.errors;
            totalLatency += result.latency;
        }

        return {
            success: true,
            findings,
            metrics: {
                totalTransactions: totalTx,
                errorRate: errors / totalTx,
                avgLatency: totalLatency / totalTx
            }
        };
    }

    private async testVulnerability(
        programId: string,
        vulnType: string
    ): Promise<{
        found: boolean;
        details: string;
        transactions: number;
        errors: number;
        latency: number;
    }> {
        const startTime = Date.now();
        let transactions = 0;
        let errors = 0;

        try {
            switch (vulnType) {
                case 'reentrancy':
                    return await this.testReentrancy(programId);
                case 'arithmetic-overflow':
                    return await this.testArithmeticOverflow(programId);
                case 'access-control':
                    return await this.testAccessControl(programId);
                case 'race-condition':
                    return await this.testRaceCondition(programId);
                default:
                    return {
                        found: false,
                        details: `Test not implemented for ${vulnType}`,
                        transactions,
                        errors,
                        latency: Date.now() - startTime
                    };
            }
        } catch (error) {
            this.logger.error(`Vulnerability test failed for ${vulnType}:`, error);
            return {
                found: false,
                details: `Test failed: ${error.message}`,
                transactions,
                errors: errors + 1,
                latency: Date.now() - startTime
            };
        }
    }

    private async testReentrancy(programId: string): Promise<{
        found: boolean;
        details: string;
        transactions: number;
        errors: number;
        latency: number;
    }> {
        const startTime = Date.now();
        let transactions = 0;
        let errors = 0;

        try {
            // Create test accounts
            const testAccount = Keypair.generate();
            const attackerAccount = Keypair.generate();

            // Attempt reentrancy attack
            const tx1 = await this.createReentrancyAttackTx(
                programId,
                testAccount.publicKey,
                attackerAccount.publicKey
            );
            transactions++;

            // Monitor for successful reentrancy
            const result = await this.connection.simulateTransaction(tx1);
            
            const found = this.analyzeReentrancyResult(result);

            return {
                found,
                details: found ? 'Reentrancy vulnerability detected' : 'No reentrancy found',
                transactions,
                errors,
                latency: Date.now() - startTime
            };
        } catch (error) {
            return {
                found: false,
                details: `Reentrancy test failed: ${error.message}`,
                transactions,
                errors: errors + 1,
                latency: Date.now() - startTime
            };
        }
    }
}
