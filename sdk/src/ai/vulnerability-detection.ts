import * as tf from '@tensorflow/tfjs-node';

export enum VulnerabilityType {
    Reentrancy = 'REENTRANCY',
    ArithmeticOverflow = 'ARITHMETIC_OVERFLOW',
    AccessControl = 'ACCESS_CONTROL',
    DenialOfService = 'DENIAL_OF_SERVICE',
    LogicError = 'LOGIC_ERROR'
}

export interface VulnerabilityPrediction {
    type: VulnerabilityType | null;
    confidence: number;
    details: string[];
}

export class VulnerabilityDetectionModel {
    private model: tf.LayersModel | null = null;

    async train(data: { features: number[]; vulnerabilityType: VulnerabilityType }[]) {
        // Convert data to tensors
        const features = data.map(d => d.features);
        const labels = data.map(d => d.vulnerabilityType);

        const xs = tf.tensor2d(features);
        const ys = tf.oneHot(tf.tensor1d(labels, 'int32'), Object.keys(VulnerabilityType).length);

        // Define model architecture
        const model = tf.sequential();
        model.add(tf.layers.dense({ units: 32, activation: 'relu', inputShape: [features[0].length] }));
        model.add(tf.layers.dense({ units: 16, activation: 'relu' }));
        model.add(tf.layers.dense({ units: Object.keys(VulnerabilityType).length, activation: 'softmax' }));

        // Compile and train
        model.compile({
            optimizer: 'adam',
            loss: 'categoricalCrossentropy',
            metrics: ['accuracy']
        });

        await model.fit(xs, ys, {
            epochs: 10,
            batchSize: 32,
            validationSplit: 0.2
        });

        this.model = model;

        // Clean up tensors
        xs.dispose();
        ys.dispose();
    }

    async predict(features: number[]): Promise<VulnerabilityPrediction> {
        if (!this.model) {
            throw new Error('Model not trained');
        }

        const input = tf.tensor2d([features]);
        const prediction = this.model.predict(input) as tf.Tensor;
        const values = await prediction.data();

        // Get top prediction
        const maxIndex = values.indexOf(Math.max(...values));
        const type = Object.values(VulnerabilityType)[maxIndex] || null;
        const confidence = values[maxIndex];

        // Clean up tensors
        input.dispose();
        tf.dispose(prediction);

        return {
            type,
            confidence,
            details: this.getDetails(type, features)
        };
    }

    private getDetails(type: VulnerabilityType | null, features: number[]): string[] {
        const details: string[] = [];
        
        if (type === VulnerabilityType.Reentrancy) {
            if (features[0] > 0.8) {
                details.push('High reentrancy risk detected');
            }
        }

        if (type === VulnerabilityType.ArithmeticOverflow) {
            if (features[1] > 0.7) {
                details.push('Potential arithmetic overflow detected');
            }
        }

        return details;
    }

    async save(path: string) {
        if (!this.model) {
            throw new Error('Model not trained');
        }
        await this.model.save(`file://${path}`);
    }

    async load(path: string) {
        this.model = await tf.loadLayersModel(`file://${path}/model.json`);
    }

    async cleanup() {
        if (this.model) {
            this.model.dispose();
        }
        await tf.disposeVariables();
    }
}
