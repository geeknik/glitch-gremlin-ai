import * as tf from '@tensorflow/tfjs-node';
import { VulnerabilityType, PredictionResult, VulnerabilityDetectionModel, MLConfig, TrainingResult } from './types.js';

export interface VulnerabilityPrediction {
    type: VulnerabilityType;
    confidence: number;
    details: string[];
}

export class VulnerabilityDetector implements VulnerabilityDetectionModel {
    private _model: tf.Sequential | null = null;
    config: MLConfig;
    private vulnTypes: string[];

    constructor(config: MLConfig) {
        this.config = config;
        this.vulnTypes = ['NONE', 'ARITHMETIC_OVERFLOW', 'ACCESS_CONTROL', 'DATA_VALIDATION', 'REENTRANCY', 'ACCOUNT_CONFUSION', 'SIGNER_AUTHORIZATION', 'CLOCK_MANIPULATION', 'LAMPORT_DRAIN', 'INSTRUCTION_INJECTION', 'RACE_CONDITION', 'PDA_VALIDATION', 'PDA_SAFETY', 'CPI_SAFETY', 'AUTHORITY_CHECK'];
    }

    get model(): tf.LayersModel {
        if (!this._model) {
            throw new Error('Model not initialized');
        }
        return this._model as unknown as tf.LayersModel;
    }

    async initialize(): Promise<void> {
        const sequential = tf.sequential();
        
        // Input layer
        sequential.add(tf.layers.dense({
            units: this.config.hiddenLayers[0],
            activation: 'relu',
            inputShape: [this.config.inputShape[0]]
        }));

        // Hidden layers
        for (let i = 1; i < this.config.hiddenLayers.length; i++) {
            sequential.add(tf.layers.dense({
                units: this.config.hiddenLayers[i],
                activation: 'relu'
            }));
            sequential.add(tf.layers.dropout({ rate: 0.2 }));
        }

        // Output layer
        sequential.add(tf.layers.dense({
            units: this.vulnTypes.length,
            activation: 'sigmoid'
        }));

        sequential.compile({
            optimizer: tf.train.adam(this.config.learningRate),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
        });

        this._model = sequential;
    }

    async train(features: number[][], labels: number[][]): Promise<TrainingResult> {
        await this.ensureInitialized();
        const xs = tf.tensor2d(features);
        const ys = tf.tensor2d(labels);

        const history = await this.model.fit(xs, ys, {
            epochs: this.config.epochs,
            batchSize: this.config.batchSize,
            validationSplit: 0.2
        });

        xs.dispose();
        ys.dispose();

        return {
            loss: Number(history.history.loss[history.history.loss.length - 1]),
            accuracy: Number(history.history.acc[history.history.acc.length - 1]),
            epochs: this.config.epochs,
            epoch: history.epoch.length,
            validationLoss: history.history.val_loss ? Number(history.history.val_loss[history.history.val_loss.length - 1]) : undefined,
            validationAccuracy: history.history.val_acc ? Number(history.history.val_acc[history.history.val_acc.length - 1]) : undefined
        };
    }

    async predict(features: number[][]): Promise<PredictionResult> {
        await this.ensureInitialized();
        const xs = tf.tensor2d(features);
        const predictions = this.model.predict(xs) as tf.Tensor;
        const predArray = await predictions.array() as number[][];
        
        xs.dispose();
        predictions.dispose();

        const maxIndex = predArray[0].indexOf(Math.max(...predArray[0]));
        const confidence = predArray[0][maxIndex];
        const vulnType = this.vulnTypes[maxIndex] as VulnerabilityType;

        return {
            vulnerabilityType: vulnType,
            confidence,
            details: this.getVulnerabilityDetails(vulnType),
            timestamp: new Date(),
            modelVersion: '1.0.0',
            prediction: predArray[0]
        };
    }

    async detectVulnerability(features: number[][]): Promise<VulnerabilityType> {
        const result = await this.predict(features);
        return result.vulnerabilityType;
    }

    async getConfidenceScore(features: number[][]): Promise<number> {
        const result = await this.predict(features);
        return result.confidence;
    }

    getVulnerabilityDetails(type: VulnerabilityType): string {
        const details = [`Detected vulnerability type: ${type}`];
        details.push(`Recommendations:`);

        switch (type) {
            case 'REENTRANCY':
                details.push('- Implement checks-effects-interactions pattern');
                details.push('- Use reentrancy guards');
                details.push('- Update state before external calls');
                break;
            case 'ACCESS_CONTROL':
                details.push('- Implement proper authorization checks');
                details.push('- Use role-based access control');
                details.push('- Add multi-signature requirements for critical operations');
                break;
            case 'ARITHMETIC_OVERFLOW':
                details.push('- Use checked math operations');
                details.push('- Implement value range validation');
                details.push('- Add overflow checks for critical calculations');
                break;
            case 'NONE':
                details.push('- No immediate vulnerabilities detected');
                details.push('- Continue monitoring for potential issues');
                break;
            default:
                details.push('- Review code for potential security issues');
                details.push('- Consider security audit');
                break;
        }

        return details.join('\n');
    }

    async ensureInitialized(): Promise<void> {
        if (!this._model) {
            await this.initialize();
        }
    }

    async cleanup(): Promise<void> {
        if (this._model) {
            this._model.dispose();
        }
        this._model = null;
    }

    async save(path: string): Promise<void> {
        await this.ensureInitialized();
        await this.model.save(`file://${path}`);
    }

    async load(path: string): Promise<void> {
        this._model = await tf.loadLayersModel(`file://${path}`) as tf.Sequential;
    }

    async dispose(): Promise<void> {
        if (this._model) {
            this._model.dispose();
        }
        this._model = null;
    }

    protected validateFeatures(features: number[]): void {
        if (!Array.isArray(features)) {
            throw new Error('Features must be an array');
        }

        if (features.length !== this.config.inputShape[0]) {
            throw new Error(`Features must have length ${this.config.inputShape[0]}`);
        }

        if (!features.every(f => typeof f === 'number' && !isNaN(f))) {
            throw new Error('All features must be valid numbers');
        }
    }

    async predictVulnerability(features: number[]): Promise<VulnerabilityPrediction> {
        const result = await this.predict([features]);
        return {
            type: result.vulnerabilityType,
            confidence: result.confidence,
            details: result.details ? result.details.split('\n') : []
        };
    }
}
