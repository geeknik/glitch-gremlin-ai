export class TreasuryManager {
    private connection: Connection;
    private programId: PublicKey;

    constructor(connection: Connection, programId: PublicKey) {
        this.connection = connection;
        this.programId = programId;
    }

    async getBalance(): Promise<number> {
        const account = await this.connection.getAccountInfo(
            GOVERNANCE_CONFIG.treasuryAddress
        );
        return account?.lamports || 0;
    }

    async transferFunds(
        to: PublicKey,
        amount: number,
        signer: Keypair
    ): Promise<string> {
        const instruction = new TransactionInstruction({
            programId: this.programId,
            keys: [
                { pubkey: GOVERNANCE_CONFIG.treasuryAddress, isSigner: false, isWritable: true },
                { pubkey: to, isSigner: false, isWritable: true },
                { pubkey: signer.publicKey, isSigner: true, isWritable: false }
            ],
            data: Buffer.from([0]) // Transfer instruction
        });

        const tx = new Transaction().add(instruction);
        return await this.connection.sendTransaction(tx, [signer]);
    }
}
export class GovernanceErrorHandler {
    static handleProposalError(error: Error): void {
        if (error instanceof GlitchError) {
            switch (error.code) {
                case ErrorCode.PROPOSAL_NOT_FOUND:
                    // Handle not found
                    break;
                case ErrorCode.PROPOSAL_NOT_ACTIVE:
                    // Handle inactive
                    break;
                case ErrorCode.PROPOSAL_ENDED:
                    // Handle ended
                    break;
                default:
                    // Handle generic error
            }
        } else {
            // Handle unexpected errors
        }
    }

    static handleVotingError(error: Error): void {
        if (error instanceof GlitchError) {
            switch (error.code) {
                case ErrorCode.INSUFFICIENT_VOTING_POWER:
                    // Handle insufficient voting power
                    break;
                case ErrorCode.ALREADY_VOTED:
                    // Handle double voting
                    break;
                default:
                    // Handle generic error
            }
        } else {
            // Handle unexpected errors
        }
    }
}
export class GlitchSDK {
    private governanceManager: GovernanceManager;
    private treasuryManager: TreasuryManager;
    private errorHandler: GovernanceErrorHandler;

    constructor(connection: Connection, programId: PublicKey) {
        this.governanceManager = new GovernanceManager(connection, programId);
        this.treasuryManager = new TreasuryManager(connection, programId);
        this.errorHandler = new GovernanceErrorHandler();
    }

    async createProposal(params: ProposalParams): Promise<string> {
        try {
            return await this.governanceManager.createProposal(params);
        } catch (error) {
            this.errorHandler.handleProposalError(error);
            throw error;
        }
    }

    async vote(proposalId: string, vote: boolean): Promise<string> {
        try {
            return await this.governanceManager.vote(proposalId, vote);
        } catch (error) {
            this.errorHandler.handleVotingError(error);
            throw error;
        }
    }

    async getTreasuryBalance(): Promise<number> {
        return await this.treasuryManager.getBalance();
    }
}
export class RateLimiter {
    private lastRequestTimes = new Map<string, number>();
    private readonly MIN_REQUEST_INTERVAL = 2000; // 2 seconds

    checkRateLimit(userId: string): void {
        const lastTime = this.lastRequestTimes.get(userId) || 0;
        if (Date.now() - lastTime < this.MIN_REQUEST_INTERVAL) {
            throw new GlitchError('Rate limit exceeded', ErrorCode.RATE_LIMIT_EXCEEDED);
        }
        this.lastRequestTimes.set(userId, Date.now());
    }
}
import { Connection, PublicKey, Transaction, TransactionInstruction, Keypair } from '@solana/web3.js';
import { GOVERNANCE_CONFIG } from './config';

export class TreasuryManager {
    private connection: Connection;
    private programId: PublicKey;

    constructor(connection: Connection, programId: PublicKey) {
        this.connection = connection;
        this.programId = programId;
    }

    async getBalance(): Promise<number> {
        const account = await this.connection.getAccountInfo(
            GOVERNANCE_CONFIG.treasuryAddress
        );
        return account?.lamports || 0;
    }

    async transferFunds(
        to: PublicKey,
        amount: number,
        signer: Keypair
    ): Promise<string> {
        const instruction = new TransactionInstruction({
            programId: this.programId,
            keys: [
                { pubkey: GOVERNANCE_CONFIG.treasuryAddress, isSigner: false, isWritable: true },
                { pubkey: to, isSigner: false, isWritable: true },
                { pubkey: signer.publicKey, isSigner: true, isWritable: false }
            ],
            data: Buffer.from([0]) // Transfer instruction
        });

        const tx = new Transaction().add(instruction);
        return await this.connection.sendTransaction(tx, [signer]);
    }
}
import { GlitchError, ErrorCode } from './errors';

export class GovernanceErrorHandler {
    static handleProposalError(error: Error): void {
        if (error instanceof GlitchError) {
            switch (error.code) {
                case ErrorCode.PROPOSAL_NOT_FOUND:
                    // Handle not found
                    break;
                case ErrorCode.PROPOSAL_NOT_ACTIVE:
                    // Handle inactive
                    break;
                case ErrorCode.PROPOSAL_ENDED:
                    // Handle ended
                    break;
                default:
                    // Handle generic error
            }
        } else {
            // Handle unexpected errors
        }
    }

    static handleVotingError(error: Error): void {
        if (error instanceof GlitchError) {
            switch (error.code) {
                case ErrorCode.INSUFFICIENT_VOTING_POWER:
                    // Handle insufficient voting power
                    break;
                case ErrorCode.ALREADY_VOTED:
                    // Handle double voting
                    break;
                default:
                    // Handle generic error
            }
        } else {
            // Handle unexpected errors
        }
    }
}
import { GlitchError, ErrorCode } from './errors';

export class RateLimiter {
    private lastRequestTimes = new Map<string, number>();
    private readonly MIN_REQUEST_INTERVAL = 2000; // 2 seconds

    checkRateLimit(userId: string): void {
        const lastTime = this.lastRequestTimes.get(userId) || 0;
        if (Date.now() - lastTime < this.MIN_REQUEST_INTERVAL) {
            throw new GlitchError('Rate limit exceeded', ErrorCode.RATE_LIMIT_EXCEEDED);
        }
        this.lastRequestTimes.set(userId, Date.now());
    }
}
import { Connection, PublicKey } from '@solana/web3.js';
import { GovernanceManager } from './governance/manager';
import { TreasuryManager } from './governance/treasury';
import { GovernanceErrorHandler } from './governance/error-handler';
import { ProposalParams } from './types';

export class GlitchSDK {
    private governanceManager: GovernanceManager;
    private treasuryManager: TreasuryManager;
    private errorHandler: GovernanceErrorHandler;

    constructor(connection: Connection, programId: PublicKey) {
        this.governanceManager = new GovernanceManager(connection, programId);
        this.treasuryManager = new TreasuryManager(connection, programId);
        this.errorHandler = new GovernanceErrorHandler();
    }

    async createProposal(params: ProposalParams): Promise<string> {
        try {
            return await this.governanceManager.createProposal(params);
        } catch (error) {
            this.errorHandler.handleProposalError(error);
            throw error;
        }
    }

    async vote(proposalId: string, vote: boolean): Promise<string> {
        try {
            return await this.governanceManager.vote(proposalId, vote);
        } catch (error) {
            this.errorHandler.handleVotingError(error);
            throw error;
        }
    }

    async getTreasuryBalance(): Promise<number> {
        return await this.treasuryManager.getBalance();
    }
}
