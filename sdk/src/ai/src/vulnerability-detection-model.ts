import * as tf from '@tensorflow/tfjs-node';
import { VulnerabilityType, PredictionResult, SecurityLevel } from '../../types.js';
import { VulnerabilityDetectionModel } from '@/types.js';
import { BaseMLModel } from './ml-model.js';

interface MLConfig {
    inputShape: number[];
    hiddenLayers: number[];
    learningRate: number;
    batchSize: number;
    epochs: number;
}

export class VulnerabilityDetector implements VulnerabilityDetectionModel {
    private model!: tf.Sequential;
    private readonly config: MLConfig;
    private initialized: boolean = false;
    private readonly modelVersion: string = '1.0.0';
    private readonly vulnTypes = Object.values(VulnerabilityType);

    constructor(config: MLConfig) {
        this.config = config;
    }

    public async ensureInitialized(): Promise<void> {
        if (!this.initialized) {
            this.model = await this.buildBaseModel();
            this.initialized = true;
        }
    }

    public async predict(features: number[][]): Promise<PredictionResult> {
        await this.ensureInitialized();
        
        const input = tf.tensor2d(features);
        const prediction = await this.model.predict(input) as tf.Tensor;
        const probabilities = await prediction.array() as number[][];
        const maxIndex = probabilities[0].indexOf(Math.max(...probabilities[0]));
        const vulnType = this.vulnTypes[maxIndex];
        const confidence = probabilities[0][maxIndex];
        const now = new Date();
        
        return {
            confidence,
            vulnerabilityType: vulnType,
            vulnerabilityInfo: {
                id: `vuln-${now.getTime()}`,
                name: vulnType,
                description: this.getVulnerabilityDetails(vulnType),
                severity: this.getVulnerabilitySeverity(vulnType),
                confidence: confidence,
                createdAt: now,
                updatedAt: now,
                evidence: [`Detected with ${confidence * 100}% confidence by ML model`],
                recommendation: this.getRecommendation(vulnType),
                details: {
                    expectedValue: 'No vulnerability',
                    actualValue: vulnType,
                    impact: this.getVulnerabilityDetails(vulnType),
                    likelihood: `${(confidence * 100).toFixed(2)}%`
                }
            }
        };
    }

    public async cleanup(): Promise<void> {
        if (this.model) {
            this.model.dispose();
        }
        this.initialized = false;
    }

    public async save(path: string): Promise<void> {
        await this.ensureInitialized();
        await this.model.save(`file://${path}`);
    }

    public async load(path: string): Promise<void> {
        this.model = await tf.loadLayersModel(`file://${path}`) as tf.Sequential;
        this.initialized = true;
    }

    private async buildBaseModel(): Promise<tf.Sequential> {
        const model = tf.sequential();

        // Input layer with dropout for regularization
        model.add(tf.layers.dense({
            units: this.config.hiddenLayers[0],
            activation: 'relu',
            inputShape: this.config.inputShape,
            kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
        }));
        model.add(tf.layers.dropout({ rate: 0.2 }));

        // Hidden layers with residual connections
        for (let i = 1; i < this.config.hiddenLayers.length; i++) {
            const layer = tf.layers.dense({
                units: this.config.hiddenLayers[i],
                activation: 'relu',
                kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
            });
            model.add(layer);
            model.add(tf.layers.dropout({ rate: 0.2 }));
        }

        // Output layer for multi-class vulnerability detection
        model.add(tf.layers.dense({
            units: this.vulnTypes.length,
            activation: 'softmax'
        }));

        // Use Adam optimizer with custom learning rate
        const optimizer = tf.train.adam(this.config.learningRate);

        model.compile({
            optimizer,
            loss: 'categoricalCrossentropy',
            metrics: ['accuracy']
        });

        return model;
    }

    private getVulnerabilityDetails(type: VulnerabilityType): string {
        switch (type) {
            case VulnerabilityType.Reentrancy:
                return 'Potential reentrancy vulnerability detected in cross-program invocations';
            case VulnerabilityType.ArithmeticOverflow:
                return 'Potential arithmetic overflow/underflow vulnerability detected';
            case VulnerabilityType.AccessControl:
                return 'Potential access control vulnerability detected';
            case VulnerabilityType.PDASafety:
                return 'Potential PDA validation vulnerability detected';
            case VulnerabilityType.CPISafety:
                return 'Potential CPI safety vulnerability detected';
            case VulnerabilityType.AccountConfusion:
                return 'Potential account confusion vulnerability detected';
            case VulnerabilityType.SignerAuthorization:
                return 'Potential signer authorization vulnerability detected';
            case VulnerabilityType.ClockManipulation:
                return 'Potential clock manipulation vulnerability detected';
            case VulnerabilityType.LamportDrain:
                return 'Potential lamport drain vulnerability detected';
            case VulnerabilityType.InstructionInjection:
                return 'Potential instruction injection vulnerability detected';
            case VulnerabilityType.RaceCondition:
                return 'Potential race condition vulnerability detected';
            case VulnerabilityType.AuthorityCheck:
                return 'Potential authority check vulnerability detected';
            default:
                return 'Unknown vulnerability type detected';
        }
    }

    private getRecommendation(type: VulnerabilityType): string {
        switch (type) {
            case VulnerabilityType.Reentrancy:
                return 'Implement reentrancy guards and follow checks-effects-interactions pattern';
            case VulnerabilityType.ArithmeticOverflow:
                return 'Implement proper arithmetic checks and use safe math operations';
            case VulnerabilityType.AccessControl:
                return 'Review and strengthen access control mechanisms';
            case VulnerabilityType.PDASafety:
                return 'Implement proper PDA validation and ownership checks';
            case VulnerabilityType.CPISafety:
                return 'Review and validate all cross-program invocations';
            case VulnerabilityType.AccountConfusion:
                return 'Implement strict account validation and type checking';
            case VulnerabilityType.SignerAuthorization:
                return 'Verify all required signers and their permissions';
            case VulnerabilityType.ClockManipulation:
                return 'Use secure time-based operations and validate timestamps';
            case VulnerabilityType.LamportDrain:
                return 'Implement proper lamport balance checks and limits';
            case VulnerabilityType.InstructionInjection:
                return 'Validate all instruction data and enforce proper ordering';
            case VulnerabilityType.RaceCondition:
                return 'Implement proper synchronization and atomic operations';
            case VulnerabilityType.AuthorityCheck:
                return 'Implement comprehensive authority validation';
            default:
                return 'Review and fix the detected vulnerability';
        }
    }

    private getVulnerabilityLocation(type: VulnerabilityType): string {
        // This would be replaced with actual code location detection
        // For now, return a generic location hint based on vulnerability type
        switch (type) {
            case VulnerabilityType.Reentrancy:
                return 'Check CPI calls in instruction handlers';
            case VulnerabilityType.ArithmeticOverflow:
                return 'Review token transfer and calculation logic';
            case VulnerabilityType.AccessControl:
                return 'Examine instruction handler entry points';
            case VulnerabilityType.PDASafety:
                return 'Review PDA derivation and validation code';
            case VulnerabilityType.CPISafety:
                return 'Analyze cross-program invocation patterns';
            default:
                return 'Location information not available';
        }
    }

    private getVulnerabilitySeverity(vulnType: VulnerabilityType): SecurityLevel {
        switch (vulnType) {
            case VulnerabilityType.Reentrancy:
            case VulnerabilityType.ArithmeticOverflow:
            case VulnerabilityType.SignerAuthorization:
                return 'CRITICAL';
            case VulnerabilityType.AccessControl:
            case VulnerabilityType.PDASafety:
            case VulnerabilityType.CPISafety:
            case VulnerabilityType.AccountConfusion:
                return 'HIGH';
            case VulnerabilityType.ClockManipulation:
            case VulnerabilityType.LamportDrain:
                return 'MEDIUM';
            default:
                return 'LOW';
        }
    }
}

